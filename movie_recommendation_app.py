{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bc85b5f9",
   "metadata": {},
   "outputs": [],
   "source": [
    "import streamlit as st\n",
    "from sklearn.feature_extraction.text import TfidfVectorizer\n",
    "from sklearn.metrics.pairwise import cosine_similarity\n",
    "from sklearn.neighbors import NearestNeighbors\n",
    "import pandas as pd\n",
    "from imdb import IMDb\n",
    "import matplotlib.pyplot as plt\n",
    "from PIL import Image\n",
    "import requests\n",
    "from io import BytesIO\n",
    "\n",
    "# Load the dataset\n",
    "# Assuming 'new_df' is your DataFrame containing movie data\n",
    "df = pd.read_csv('/Users/muralikrishnaavula/Downloads/datasets_24/movie_data.csv')\n",
    "\n",
    "# Define recommendation functions\n",
    "# Define recommendation functions\n",
    "def content_based_recommendations(title, df, n_recommendations=6):\n",
    "    # Preprocess text data\n",
    "    df['combined_text'] = df['combined_text'].str.lower()\n",
    "    \n",
    "    # TF-IDF vectorization\n",
    "    tfidf_vectorizer = TfidfVectorizer()\n",
    "    tfidf_matrix = tfidf_vectorizer.fit_transform(df['combined_text'])\n",
    "    \n",
    "    # Calculate cosine similarity between movies\n",
    "    cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)\n",
    "    \n",
    "    # Get index of the input movie\n",
    "    idx = df[df['title'].str.lower() == title.lower()].index[0]\n",
    "    \n",
    "    # Get similarity scores of the input movie with all other movies\n",
    "    sim_scores = list(enumerate(cosine_sim[idx]))\n",
    "    \n",
    "    # Sort movies based on similarity scores\n",
    "    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n",
    "    \n",
    "    # Get top recommendations\n",
    "    top_recommendations = sim_scores[1:n_recommendations+1]\n",
    "    top_movie_indices = [i[0] for i in top_recommendations]\n",
    "    \n",
    "    return df.iloc[top_movie_indices]['title'].tolist()\n",
    "\n",
    "def collaborative_filtering_recommendations(title, df, n_neighbors=10, n_recommendations=6):\n",
    "    # Select relevant columns for fitting the model\n",
    "    numeric_df = df[['release_year', 'voting']]\n",
    "    \n",
    "    # Use Nearest Neighbors algorithm\n",
    "    nn_model = NearestNeighbors(n_neighbors=n_neighbors, metric='cosine')\n",
    "    nn_model.fit(numeric_df)\n",
    "    \n",
    "    # Get index of the input movie\n",
    "    idx = df[df['title'].str.lower() == title.lower()].index[0]\n",
    "    \n",
    "    # Find nearest neighbors\n",
    "    distances, indices = nn_model.kneighbors([numeric_df.iloc[idx]])\n",
    "    \n",
    "    # Get indices of nearest neighbors\n",
    "    neighbor_indices = indices.flatten()[1:]\n",
    "    \n",
    "    # Get top recommendations\n",
    "    top_recommendations = df.iloc[neighbor_indices]['title'].tolist()[:n_recommendations]\n",
    "    \n",
    "    return top_recommendations\n",
    "\n",
    "def combined_recommendations(title, df, content_based_weight=0.5, n_recommendations=6):\n",
    "    # Get recommendations using content-based filtering\n",
    "    content_based_recs = content_based_recommendations(title, df, n_recommendations)\n",
    "    \n",
    "    # Get recommendations using collaborative filtering\n",
    "    collaborative_recs = collaborative_filtering_recommendations(title, df, n_neighbors=10, n_recommendations=n_recommendations)\n",
    "    \n",
    "    # Combine recommendations from both methods\n",
    "    combined_recs = list(set(content_based_recs) | set(collaborative_recs))\n",
    "    \n",
    "    return combined_recs\n",
    "\n",
    "# Function to fetch poster URL for a movie title\n",
    "def get_poster_url(title):\n",
    "    # Create an instance of the IMDb class\n",
    "    ia = IMDb()\n",
    "    \n",
    "    # Search for movies by title\n",
    "    movies = ia.search_movie(title)\n",
    "    \n",
    "    # If multiple movies are found with the same title, choose the first one\n",
    "    if movies:\n",
    "        movie = movies[0]\n",
    "        \n",
    "        # Get movie details, including the poster URL if available\n",
    "        ia.update(movie)\n",
    "        \n",
    "        # Check if poster URL is available\n",
    "        if 'cover url' in movie.keys():\n",
    "            return movie['cover url']\n",
    "        else:\n",
    "            return None\n",
    "    else:\n",
    "        return None\n",
    "\n",
    "# Function to display movie posters in a grid\n",
    "def display_poster_grid(movie_titles, ncols=3):\n",
    "    nrows = -(-len(movie_titles) // ncols)  # Ceiling division to calculate the number of rows\n",
    "    fig, axes = plt.subplots(nrows=nrows, ncols=ncols, figsize=(15, 5*nrows))  # Adjust figsize as needed\n",
    "\n",
    "    for i, movie_title in enumerate(movie_titles):\n",
    "        poster_url = get_poster_url(movie_title)\n",
    "        if poster_url:\n",
    "            response = requests.get(poster_url)\n",
    "            img = Image.open(BytesIO(response.content))\n",
    "            ax = axes[i // ncols, i % ncols]\n",
    "            ax.imshow(img)\n",
    "            ax.set_title(movie_title, fontsize=10, pad=5)  # Set title above the poster with padding\n",
    "            ax.axis('off')\n",
    "        else:\n",
    "            axes[i // ncols, i % ncols].axis('off')\n",
    "            axes[i // ncols, i % ncols].set_title(\"Poster not available\", fontsize=10, pad=5)\n",
    "\n",
    "    # Hide empty subplots\n",
    "    for j in range(i + 1, len(movie_titles)):\n",
    "        axes[j // ncols, j % ncols].axis('off')\n",
    "\n",
    "    plt.tight_layout()\n",
    "    st.pyplot(fig)\n",
    "\n",
    "# Streamlit app\n",
    "st.title(\"Movie Recommendation System\")\n",
    "\n",
    "# Dropdown for selecting movie title\n",
    "movie_title = st.selectbox(\"Select a movie title\", new_df['title'])\n",
    "\n",
    "# Button to trigger recommendations\n",
    "if st.button(\"Get Recommendations\"):\n",
    "    # Get recommendations\n",
    "    recommended_movies = combined_recommendations(movie_title, new_df)\n",
    "    if recommended_movies:\n",
    "        st.success(\"Here are your recommended movies:\")\n",
    "        display_poster_grid(recommended_movies)\n",
    "    else:\n",
    "        st.warning(\"No recommendations found.\")\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
